ЛАБОРАТОРНАЯ РАБОТА №7
МЕЖПРОЦЕССНЫЕ КОММУНИКАЦИИ В LINUX. КАНАЛЫ.

1. ЦЕЛЬ РАБОТЫ: 
Изучить способы и средства обмена информацией между процессами средствами неименованных или именованных каналов в программах на языке C в операционных системах семейства Linux.

2. КРАТКИЕ ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ.
Программные (неименованные) каналы не имеют имен, и их главным недостатком является невозможность передачи информации между не родственными процессами. Канал создается вызовом piре и предоставляет возможность однонаправленной (односторонней) передачи данных:
	#include <unistd.h> 
	int pipe(int fd[2]); 
и возвращает 0 в случае успешного завершения, -1 - в случае ошибки. Функция возвращает два файловых дескриптора: fd[0] и fd[1], причем первый открыт для чтения, а второй — для записи.
При необходимости передачи данных в обе стороны нужно создавать пару каналов и использовать каждый из них для передачи данных в одну сторону. Этапы создания двунаправленного канала IPC следующие:
Создаются каналы 1 (fdl[0] и fdl[l]) и 2 (fd2[0] и fd2[l]).
Производится вызов fork.
Родительский процесс закрывает доступный для чтения конец канала 1 (fdl [0] ) и доступный для записи конец канала 2 (fd2[l]).
Дочерний процесс закрывает доступный для записи конец канала 1 (fd1[1]) и доступный для чтения конец канала 2 (fd2[0]).
Текст программы mainpipe.c доступен на сайте в папке «Pipes».
Еще один пример работы неименованных каналов для передачи строки:
//--- pipe.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#define MAX_LEN 80

int main(int argc, char **argv){
	int fd[2];
	pid_t pid;
	char str[] = "Simple string\n";
	char buf[MAX_LEN];

	pipe(fd);
	pid = fork();
	if(-1 == pid){
		perror("fork");
		exit(1);
	} else if(0 == pid){
		/* процесс-потомок закрывает доступный для чтения конец канала 0*/
		close(fd[0]);
		/* записывает в канал 1*/
		write(fd[1], str, (strlen(str)+1));
		exit(0);
	} else {
		/* процесс-родитель закрывает доступный для записи конец канала 1*/
		close(fd[1]);
		/* читает из канала 0*/
		read(fd[0], buf, sizeof(buf));
		printf("Received string: %s", buf);
	}
	return(0);
}
//---------------
Другим примером использования неименованных каналов является имеющаяся в стандартной библиотеке ввода-вывода функция рореn, которая создает канал и запускает другой процесс, записывающий данные в этот канал или считывающий их из него:
	#include <stdio.h>
	FILE *popen(const char *command, const char *type);
	int pclose(FILE *stream);
Аргумент command представляет собой команду интерпретатора. Он обрабатывается программой sh (интерпретатор Bourne shell), поэтому для поиска исполняемого файла, вызываемого командой command, используется переменная PATH. Канал создается между вызывающим процессом и указанной командой. Возвращаемое функцией рореn значение представляет собой NULL - в случае ошибки или обычный указатель на тип FILE, который может использоваться для ввода или для вывода в зависимости от содержимого строки type:
если type имеет значение r, вызывающий процесс считывает данные, направляемые командой command в стандартный поток вывода;
если type имеет значение w, вызывающий процесс записывает данные в стандартный поток ввода команды command.
Функция pclose закрывает стандартный поток ввода-вывода stream, созданный командой рореn, ждет завершения работы программы и возвращает код завершения, принимаемый от интерпретатора или -1 - в случае ошибки.
Пример работы popen для выполнения любой команды linux, которая будет передаваться через командную строку:
//--- popen.c
#include <stdio.h>
#define MAX_LEN 80
int main(int argc, char *argv[]){
	FILE *pipein_fp, *pipeout_fp;
	char readbuf[MAX_LEN];
	if (( pipein_fp = popen(argv[1], "r")) == NULL){
		perror("popen");
		exit(1);
	}
	while(fgets(readbuf, MAX_LEN, pipein_fp)){
		printf("%s",readbuf);
	}
	pclose(pipein_fp);
	return(0);
}

//--- myls.c
#include <stdlib.h>
int main(int argc, char *argv[]){
	system("ls -la");
	return(0);
}

+===============+
$ ./popen ls
$ ./popen ./myls
$ ./popen "ls -la"
+===============+

Пример работы каналов в могопоточной программе, которая считает в дочерних процессах длину строки из аргументов командной строки:
//--- pipe_many.c
#include <sys/types.h>
#include <sys/stat.h>
#include <wait.h>
#include <fcntl.h> 
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char *argv[]) {
    int i, pid[argc], status, stat;
            
    if (argc < 2) {
        printf("Usage: ./fork_many text text ...\n");
        exit(-1);
    }
    int fd[argc][2];
    for (i = 1; i < argc; i++) {
        pipe(fd[i]);
        pid[i] = fork();
        srand(getpid());
		
        if (-1 == pid[i]) {
            perror("fork"); /* произошла ошибка */
            exit(1); /*выход из родительского процесса*/
        } else if (0 == pid[i]) {
			/* процесс-потомок закрывает доступный для чтения конец канала 0*/
            close(fd[i][0]);
			/* записывает в канал 1*/
			int len = strlen(argv[i]);
			write(fd[i][1], &len, sizeof(int));
            exit(0);
        }
    }
    // если выполняется родительский процесс
    printf("PARENT: Это процесс-родитель!\n");
    // ожидание окончания выполнения всех запущенных процессов
    for (i = 1; i < argc; i++) {
        status = waitpid(pid[i], &stat, 0);
        if (pid[i] == status) {
			printf("процесс-потомок %d done,  result=%d\n", i, WEXITSTATUS(stat));
			/* процесс-родитель закрывает доступный для записи конец канала 1*/
			close(fd[i][1]);
			/* читает из канала 0*/
			int len = 0;
			read(fd[i][0], &len, sizeof(int));
			printf("i=%d len=%d\n", i, len );
        }
    }
    return 0;
}
//---------------

Именованные каналы (FIFO) в Unix функционируют подобно неименованным — они позволяют передавать данные только в одну сторону.
Однако в отличие от программных каналов каждому каналу FIFO сопоставляется полное имя в файловой системе, что позволяет двум неродственным процессам обратиться к одному и тому же FIFO.
FIFO создается функцией mkfifo:
	#include <sys/types.h>
	#include <sys/stat.h>
	int mkfifo(const char *pathname, mode_t mode),
	/* Возвращает 0 при успешном выполнении  -1 - при возникновении ошибок */
После создания канал FIFO должен быть открыт на чтение или запись с помощью либо функции open, либо одной из стандартных функций открытия файлов из библиотеки ввода-вывода (например, fopen).
FIFO может быть открыт либо только на чтение, либо только на запись.
Нельзя открывать канал на чтение и запись, поскольку именованные каналы могут быть только односторонними.
При записи в программный канал или канал FIFO вызовом write данные всегда добавляются к уже имеющимся, а вызов read считывает данные, помещенные в программный канал или FIFO первыми.
Заметим, что чтение из FIFO блокирует процесс, если канал еще не открыт на запись каким-либо другим процессом.
Пример:
//--- fifo.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <unistd.h>
#include <fcntl.h>

#define FIFO1 "/tmp/fifo.1"
#define MAXLINE 80

void doit(char **argv){
	pid_t pid;
	int status = 0;
	int readfd, writefd;
	char buff[MAXLINE+1];
	ssize_t len, n;
	
	pid = fork();
	mkfifo(FIFO1, 0666);
	if (-1 == pid) {
		perror("fork"); /* произошла ошибка */
		exit(1); /*выход из родительского процесса*/
	} else if (0 == pid){
		printf(" CHILD: Это процесс-потомок!\n");
		len = strlen(argv[1]);
		writefd = open(FIFO1, O_WRONLY, 0);
		sleep(5);
		/* запись в канал IPC */
		write(writefd, argv[1], len);
		close(writefd);
		exit(status); /* выход из процесс-потомока */ 
	} else {
		printf("PARENT: Это процесс-родитель!\n");
		readfd = open(FIFO1, O_RDONLY, 0);
		len = strlen(argv[1]);
		/* считывание из канала */
		while ( (n = read(readfd, buff, len)) > 0);
		printf(buff);
		close(readfd); 
		if (wait(&status) == -1){
			perror("wait() error");
		} else if (WIFEXITED(status)){
			printf("PARENT: Код возврата потомка: %d\n", WEXITSTATUS(status));
		} else {
			perror("PARENT: потомок не завершился успешно");
		}
	} 
}

int main(int argc, char **argv){
	doit(argv);
	return 0;
}
//---------------

Примеры клиент-серверных приложений, использующих неименованные и именованные каналы, доступны по адресу http://gun.cs.nstu.ru/ssw/Pipes.

6. КОНТРОЛЬНЫЕ ВОПРОСЫ. 
1. Что такое каналы? В чем отличие неименованных и именованных каналов?
2. В чем разница при использовании для коммуникаций процессов файлов и каналов?
3. Опишите функции создания и использования неименованных каналов.
4. Чем работа с неименованными каналами отличается от работы с файлами?
5. Опишите особенности использования функции popen().
6. Опишите особенности создания и уничтожения именованных каналов в сравнении с неименованными каналами.
7. Чем работа (чтение/запись) с именованными каналами отличается от работы с неименованными каналами?
8. В каких случаях при работе с неименованными каналами и именованными каналами возникают блокировки в программе?
9. Каковы особенности обхода блокировок при работе с неименованными каналами?
10. Каковы особенности поведения функций работы с каналами при обходе блокировок?

!===============!
СОСТАВИТЕЛИ:
Гунько А.В., канд. техн. наук, доц. НГТУ
Чистяков Н.А., инженер НГТУ
!===============!
ССЫЛКИ:
http://gun.cs.nstu.ru/ssw/sysV.zip
http://gun.cs.nstu.ru/ssw/SystemV%20IP
http://gun.cs.nstu.ru/ssw/Pipes/
http://gun.cs.nstu.ru/ssw/pipes.zip
http://gun.cs.nstu.ru/ssw/Linuxprog.zip
http://gun.cs.nstu.ru/ssw/Linuxprog/
http://www.ibm.com/developerworks/ru/library/au-ipc/
http://www.tldp.org/LDP/lpg/node11.html
http://www.tldp.org/LDP/lpg/node12.html
http://stackoverflow.com/questions/2784500/how-to-send-a-simple-string-between-two-programs-using-pipes
https://www.opennet.ru/man.shtml?topic=pipe&category=2&russian=2
!===============!
