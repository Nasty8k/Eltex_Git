ЛАБОРАТОРНАЯ РАБОТА №9
МЕЖПРОЦЕССНЫЕ КОММУНИКАЦИИ В LINUX. СЕМАФОРЫ И РАЗДЕЛЯЕМАЯ ПАМЯТЬ.

1. ЦЕЛЬ РАБОТЫ: 
Изучить способы и средства обмена информацией между процессами средствами семафоров и разделяемой памяти в программах на языке C в операционных системах семейства Linux.

2. КРАТКИЕ ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ.

РАЗДЕЛЯЕМАЯ ПАМЯТЬ.
Разделяемая память является самым быстрым средством межпроцессного взаимодействия. После отображения области памяти в адресное пространство процессов, совместно ее использующих, для передачи данных между процессами не требуется участие ядра. Обычно, однако, требуется некоторая форма синхронизации процессов (как правило, семафоры), помещающих данные в разделяемую память и считывающих ее оттуда.
Для каждого сегмента разделяемой памяти ядро хранит структуру shimd_ds, определенную в заголовочном файле <sys/shm.h>:
struct shimd_ds {
	struct ipc_perm shm_perm; /* структура разрешений */
	size_t shm_segsz; /* размер сегмента */
	pid_t shm_lpid; /* идентификатор последнего процесса*/
	pid_t shm_cpid; /*идентификатор процесса-создателя*/
	shmatt_t shm_nattch;/*текущее количество подключений*/
	shmat_t shm_cnattch; // количество подключений in-core 
	time_t shm_atime; /* время последнего подключения */
	time_t shm_dtime; /* время последнего отключения */
	time_t shm_ctime; /*время последнего изменения */ 
};

Структура ipc_perm содержит разрешения доступа к сегменту разделяемой памяти.
С помощью функции shmget можно создать новый сегмент разделяемой памяти или подключиться к существующему:
	#include <sys/shm.h>
	int shmget(key_t key, size_t size, int oflag);

Возвращаемое целочисленное значение называется идентификатором разделяемой памяти. Он используется с тремя другими функциями shmXXX. В случае ошибки возвращается -1.
Аргумент key может содержать значение, возвращаемое функцией ftok, или константу IPC_PRIVATE. Аргумент size указывает размер сегмента в байтах. При создании нового сегмента разделяемой памяти нужно указать ненулевой размер. Если производится обращение к существующему сегменту, аргумент size должен быть нулевым.
Флаг oflag представляет собой комбинацию флагов доступа на чтение и запись. К ним могут быть добавлены с помощью логического сложения флаги IPC_CREAT или IPC_CREAT | IPC_EXCL. Новый сегмент инициализируется нулями.
Функция shmget создает или открывает сегмент разделяемой памяти, но не дает вызвавшему процессу доступа к нему. Для подключения сегмента разделяемой памяти к адресному пространству процесса предназначена функция shmat:
	void *shmat(int shmid, const void *shmaddr, int flag);

Аргумент shmid — это идентификатор разделяемой памяти, возвращенный shmget. Функция shmat возвращает адрес начала области разделяемой памяти в адресном пространстве вызвавшего процесса или -1 в случае ошибки. Правила формирования адреса таковы:
если аргумент shmaddr представляет собой нулевой указатель, система сама выбирает начальный адрес. Это рекомендуемый (и обеспечивающий наилучшую совместимость) метод;
если shmaddr отличен от нуля, возвращаемый адрес зависит от того, был ли указан флаг SHM_RND (в аргументе flag);
если флаг SHM_RND не указан, разделяемая память подключается непосредственно с адреса, указанного аргументом shmaddr ;
если флаг SHM_RND указан, сегмент разделяемой памяти подключается с адреса, указанного аргументом shmaddr, округленного вниз до кратного константе SHMLBA. Аббревиатура LBA означает lower boundary address — нижний граничный адрес.
По умолчанию, при наличии разрешений, сегмент подключается для чтения и записи. В аргументе flag можно указать константу SHM_RDONLY, которая позволит установить доступ только на чтение.

После завершения работы с сегментом разделяемой памяти его следует отключить вызовом shmdt:
	int shmdt(const void *shmaddr);

Функция возвращает 0 в случае успешного завершения, -1 - в случае ошибки. Эта функция не удаляет сегмент разделяемой памяти. Удаление осуществляется функцией shmctl с командой IPC_RMID. При завершении работы процесса все сегменты, которые не были отключены им явно, отключаются автоматически, но не удаляются.

Функция shmctl позволяет выполнять различные операции с сегментом разделяемой памяти:
	int shmctl(int shmid, int cmd, struct shmid_ds *buff);

Функция возвращает 0 в случае успешного завершения, -1 в случае ошибки. Команд (значений аргумента cmd) может быть три:
1. IPC_RMID — удаление сегмента разделяемой памяти с идентификатором shmid из системы;
2. IPC_SET — установка значений полей структуры shmid_ds для сегмента разделяемой памяти равными значениям соответствующих полей структуры, на которую указывает аргумент buff: shm_perm.uid, shm_perm.gid, shm_perm.mode. Значение поля shm_ctime устанавливается равным текущему системному времени;
3. IPC_STAT — возвращает (через аргумент buff) текущее значение структуры shmid_ds для указанного сегмента разделяемой памяти.

//--- shm_fork.c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
int main(int argc, const char *argv[]){
    
    int *shm, *s, shmid, count = 10;
    
    if (argc < 2){
		fprintf (stderr, "Используйте %s <число>\n", argv[0]);
		exit (1);
	}
	
    sscanf(argv[1], "%d", &count);
    
    int size = sizeof(int)*count;
    
    /* Создадим область разделяемой памяти */
    if ((shmid = shmget(IPC_PRIVATE, size, IPC_CREAT | 0666)) < 0) {
        perror("shmget");
        exit(1);
    }
    /* Получим доступ к разделяемой памяти */
    if ((shm = shmat(shmid, NULL, 0)) == (int *) -1) {
        perror("shmat");
        exit(1);
    }

    /* Запишем в разделяемую память */
    	s = shm;
	for (int i = 0; i < count; i++){
		s[i] = i; //*s++ = i;
	}
	
	pid_t pid;
	pid = fork();
	if (0 == pid) {

		/* Прочитаем из разделяемой памяти */
		s = shm;
		for (int i = 0; i < count; i++){
			printf("%d ", s[i]*s[i]);//s[i]*s[i] = *s**s++
		}	
		
		if (shmdt(shm) < 0) {
			printf("Ошибка отключения\n");
			exit(1);
		} 
		exit(0);
		
	} else if (pid < 0){
		perror("fork"); /* произошла ошибка */
		exit(1); /*выход из родительского процесса*/
	}	
	
	wait(NULL);
	
	/* Удалим созданные объекты IPC */	
	 if (shmctl(shmid, IPC_RMID, 0) < 0) {
		printf("Невозможно удалить область\n");
		exit(1);
	}
    exit(0);
}
//---------------

+===============+
$ ./shm_fork 10
0 1 4 9 16 25 36 49 64 81
+===============+

СЕМАФОРЫ.
Семафор — особая структура, содержащая число, большее или равное нулю, и управляющая цепочкой процессов, ожидающих особого состояния на данном семафоре. Семафоры могут использоваться для контролирования доступа к ресурсам: число в семафоре представляет собой количество процессов, которые могут получить доступ к данным. 
Каждый раз, когда процесс обращается к данным, значение в семафоре, должно быть уменьшено на единицу, и увеличено, когда работа с данными будет прекращена. Если ресурс эксклюзивный, то есть к данным должен иметь доступ только один процесс, то начальное значение в семафоре следует установить единицей. 
Семафоры можно использовать и для других целей, например для счётчика ресурсов. В этом случае число в семафоре — количество свободных ресурсов (например, количество свободных ячеек памяти). 
Рассмотрим реализацию семафоров в System V. Создаёт семафор функция semget:
	int semget(key_t key, int nsems, int semflg); 

Здесь key — IPC ключ, nsems — число семафоров, которое мы хотим создать, и semflg — права доступа К разрешениям можно добавить флаги IРС_СRЕАТ или IPC_CREAT | IPC_EXCL с помощью логического сложения. Более полная информация доступна в man ipc. 
System V создаёт сразу несколько семафоров, что уменьшает код. Рассмотрим создание семафора на примере программы semop1.c, доступной для скачивания на сайте в разделе «Semaphores».http://gun.cs.nstu.ru/ssw/SysVshm/
Управление происходит с помощью функции semctl: 
	int semctl(int semid, int semnum, int cmd, ...); 
которая выполняет действие cmd на наборе семафоров semid или  на одном семафоре с номером semnum. В зависимости от команды, может понадобится указать ещё один аргумент следующего типа: 
	union semun {
		int val;   /* значение для SETVAL */
		struct semid_ds *buf; /*буферы для IPC_STAT, IPC_SET */
		unsigned short *array; /* массивы для GETALL, SETALL */
		struct seminfo *__buf; /* буфер для IPC_INFO */
	};

Чтобы инициализировать значение семафора, используют директиву SETVAL, новое значение должно быть указано в semun:
	/* создать только один семафор */
	semid = semget(key, 1, 0666 | IPC_CREAT);
	/* в семафоре 0 установить значение 1 */
	union semun arg;
	arg.val = 1;
	semctl(semid, 0, SETVAL, arg);

Использовать семафор можно с помощью процедуры semop: 
	int semop(int semid, struct sembuf *sops, unsigned nsops);

Здесь semid — идентификатор набора семафоров, sops — массив, содержащий операции, которые необходимо произвести, nsops — число этих операций. Каждая операция представляется структурой sembuf: 
unsigned short sem_num; short sem_op; short sem_flg; 
Операции, которые мы можем указать, являются целыми числами и подчиняются трем правилам: 
1. sem_op < 0
Если модуль значения в семафоре больше или равен модулю sem_op, то sem_op добавляется к значению в семафоре (т.е. значение в семафоре уменьшается). Если модуль sem_op больше, то процесс переходит в спящий режим, пока не будет достаточно ресурсов. 
2. sem_op = 0
Процесс спит, пока значение в семафоре не достигнет нуля. 
3. sem_op > 0
Значение sem_op добавляется к значению в семафоре, используемый ресурс освобождается. 

Примеры операций с эксклюзивным семафором номер 0 (для блокировки одновременного доступа процессов к ресурсу):
	struct sembuf lock_res = {0, -1, 0}; //блокировка ресурса
	struct sembuf rel_res = {0, 1, 0}; //освобождение ресурса

Примеры операций с семафором – счетчиком ресурсов:
	struct sembuf push = {1, -1, IPC_NOWAIT}; //уменьшить
	struct sembuf pop = {1, 1, IPC_NOWAIT}; //увеличить

Чтобы удалить семафор номер 0, освобождая структуры, использовавшиеся для управления им, используем директиву IPC_RMID. Она удаляет семафор и посылает сообщение об этом всем процессам, ожидающим доступа к ресурсу: 
	semctl(semid, 0, IPC_RMID);
Примеры клиент-серверных приложений, использующих семафоры, доступны по адресу http://gun.cs.nstu.ru/ssw/Semaphores, а примеры применения разделяемой памяти находятся здесь: http://gun.cs.nstu.ru/ssw/SysVshm.

Пример программы которая считает сумму всех элементов матрицы из файла.
Сумма каждой строки считывается в отдельном процессе, а результат складывается в разделяемую память.
Для синхронизации работы с разделяемой памятью используется семафор:
//--- sum_shm.c
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <ctype.h>

#define MAX_LEN 1024
union semun {
 int val;                  /* значение для SETVAL */
 struct semid_ds *buf;     /* буферы для  IPC_STAT, IPC_SET */
 unsigned short *array;    /* массивы для GETALL, SETALL */
                           /* часть, особенная для Linux: */
 struct seminfo *__buf;    /* буфер для IPC_INFO */
};

/* сумма элементов массива в строке */
double execMath(char * str){
  char *end, *start = str;
  end = start;
  double result = 0;
  while(*start) {
	result += strtod(start, &end);
    start = end;
    while(!isdigit(*start) && *start) start++;
  }
  return result;
}	

void sumMatrixFromFile(char* fileName){
	FILE *fp;
	char str[MAX_LEN];
	int cntStr = 0;
	
	if((fp = fopen(fileName, "r")) == NULL) {
		printf("Не удается открыть файл.\n");
		exit(1);
	}

	/* Выводим содержимое и считае кол-во строк */
	printf("File %s:\n", fileName);
	while(!feof(fp)) {
		if(fgets(str, MAX_LEN, fp)){
			printf("%s", str);
			cntStr++;
		}	
	}
	rewind(fp);	//перемещает указатель файла в начало файла
	
	pid_t pid[cntStr];
	pid_t wpid;
	int status = 0;
	
	int shmid;
	key_t key = 69;
	double *shm;
	
	int semid;
	union semun arg;
	struct sembuf lock_res = {0, -1, 0};	//блокировка ресурса
	struct sembuf rel_res = {0, 1, 0};	//освобождение ресурса
	
	 /* Получим ключ, Один и тот же ключ можно использовать как
    для семафора, так и для разделяемой памяти */
	if ((key = ftok(".", 'S')) < 0) {
		printf("Невозможно получить ключ\n");
		exit(1);
	}
	
	/* Создадим семафор - для синхронизации работы с разделяемой памятью.*/
	semid = semget(key, 1, 0666 | IPC_CREAT);
	
	/* Установить в семафоре № 0 (Контроллер ресурса) значение "1" */
	arg.val = 1;
	semctl(semid, 0, SETVAL, arg);
	 
	 /* Создадим область разделяемой памяти */
	if ((shmid = shmget(key, sizeof(double), IPC_CREAT | 0666)) < 0) {
		perror("shmget");
		exit(1);
	}
  
	for (int i = 0; i < cntStr; i++){
		if(fgets(str, MAX_LEN, fp)){
			pid[i] = fork();
			srand(getpid());
			if (0 == pid[i]) {
				printf("PID=%d i=%d\n", getpid(), i);
				printf("%s", str);
				fflush(stdout);
				
				double sum = execMath(str);
				printf("Math avarage = %f\n", sum);
				fflush(stdout);
			
				/* Получим доступ к разделяемой памяти */
				if ((shm = (double *)shmat(shmid, NULL, 0)) == (double *) -1) {
					perror("shmat");
					exit(1);
				}
				
				printf("Процесс ожидает PID=%d i=%d\n", getpid(), i);
				fflush(stdout);
				
				/* Заблокируем разделяемую память */	
				if((semop(semid, &lock_res, 1)) == -1){
					fprintf(stderr, "Lock failed\n");
					exit(1);
				} else{
					printf("Semaphore resources decremented by one (locked) i=%d\n", i);
					fflush(stdout);
				}
				
				/* Запишем в разделяемую память сумму */
				*(shm) = *(shm) + sum;
				sleep(rand() % 4);
				 
				/* Освободим разделяемую память */
				if((semop(semid, &rel_res, 1)) == -1){
					 fprintf(stderr, "Unlock failed\n");
					 exit(1);
				} else{
					printf("Semaphore resources incremented by one (unlocked) i=%d\n", i);
					fflush(stdout);
				}
				
				printf("Math avarage [i=%d] = %f\n", i, *(shm));
				fflush(stdout);
				
				 /* Отключимся от разделяемой памяти */
				if (shmdt(shm) < 0) {
					printf("Ошибка отключения\n");
					exit(1);
				}
				exit(0);
			}	else if (pid[i]<0){
					perror("fork"); /* произошла ошибка */
					exit(1); /*выход из родительского процесса*/
			}
		}
	}
	
	
	if(fclose(fp)) 
		printf("Ошибка при закрытии файла.\n");
	
	for (int i = 0; i < cntStr; i++) {
		wpid = waitpid(pid[i], &status, 0);
		if (pid[i] == wpid) {
			printf("процесс-потомок %d done,  result=%d\n", i, WEXITSTATUS(status));
			fflush(stdout);
		}
	}	

	/* Получим доступ к разделяемой памяти */
	if ((shm = (double*)shmat(shmid, NULL, 0)) == (double *) -1) {
		perror("shmat");
		exit(1);
	}

	printf("------------------\n");
	printf("Сумма=[%f]\n", *(shm));
	fflush(stdout);

	if (shmdt(shm) < 0) {
		printf("Ошибка отключения\n");
		exit(1);
	} 
	
	/* Удалим созданные объекты IPC */	
	 if (shmctl(shmid, IPC_RMID, 0) < 0) {
		printf("Невозможно удалить область\n");
		exit(1);
	} else
		printf("Сегмент памяти помечен для удаления\n");
	
	if (semctl(semid, 0, IPC_RMID) < 0) {
		printf("Невозможно удалить семафор\n");
		exit(1);
	}
	
}	

int main(int argc, char **argv){
	 if (argc < 2) {
        printf("Usage: ./mean_shtm filename\n");
        exit(-1);
    }
	sumMatrixFromFile(argv[1]);
	return 0;
}
//---------------

+===============+
$ cat test.txt
10, 12, 13, 14
1, 20.2, 33.3, 0, 11, 1
$ ./sum_shm test.txt
File test.txt:
10, 12, 13, 14
1, 20.2, 33.3, 0, 11, 1
PID=6997 i=0
10, 12, 13, 14
Math avarage = 49.000000
PID=6998 i=1
1, 20.2, 33.3, 0, 11, 1
Процесс ожидает PID=6997 i=0
Math avarage = 66.500000
Semaphore resources decremented by one (locked) i=0
Процесс ожидает PID=6998 i=1
Semaphore resources incremented by one (unlocked) i=0
Math avarage [i=0] = 49.000000
Semaphore resources decremented by one (locked) i=1
процесс-потомок 0 done,  result=0
Semaphore resources incremented by one (unlocked) i=1
Math avarage [i=1] = 115.500000
процесс-потомок 1 done,  result=0
------------------
Сумма=[115.500000]
Shared memory segment marked for deletion
+===============+



6. КОНТРОЛЬНЫЕ ВОПРОСЫ. 
1. Что такое семафоры? Какими они могут быть?
2. Каковы особенности создания и удаления семафоров?
3. Как производится инициализация значений семафоров?
4. Каковы допустимые операции с семафорами?
5. Когда возникают блокировки процессов при работе с семафорами и как их обойти?
6. Что такое сегмент разделяемой памяти? Где он находится?
7. Каковы особенности создания и получения доступа к существующему сегменту разделяемой памяти?
8. Каковы особенности подключения к сегменту разделяемой памяти?
9. В чем заключается работа с сегментом разделяемой памяти?
10. Зачем нужно отключение сегмента разделяемой памяти и чем оно отличается от его удаления?

!===============!
СОСТАВИТЕЛИ:
Гунько А.В., канд. техн. наук, доц. НГТУ
Чистяков Н.А., инженер НГТУ
!===============!

!===============!
ССЫЛКИ:
http://gun.cs.nstu.ru/ssw/svshm.zip
http://gun.cs.nstu.ru/ssw/SysVshm/
https://habrahabr.ru/post/122108/
http://www.tldp.org/LDP/lpg/node65.html
http://rus-linux.net/MyLDP/BOOKS/lpg-04/node6.htm
http://wm-help.net/lib/b/book/173895509/184
!===============!
